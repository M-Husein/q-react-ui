import { useRef, useEffect } from 'react';

/**
 * A React Hook to enable advanced indentation in a textarea.
 *
 * Features:
 * 1. Tab key inserts indentation string at cursor or indents selected lines.
 * 2. Shift+Tab unindents selected lines.
 * 3. Custom indentation string (e.g., '\t', '  ', '    ').
 *
 * @param {string} [indentString='\t'] The string to use for indentation (e.g., '\t' for tab, '  ' for 2 spaces).
 * @returns {React.RefObject<HTMLTextAreaElement | null>} A ref to be attached to the textarea element.
 */
export const useTabToIndent = (indentString: string = '\t'): React.RefObject<HTMLTextAreaElement | null> => {
  // Create a ref to attach to the textarea element
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    const textarea = textareaRef.current;

    // If the ref is not attached to a textarea yet, or it's unmounted, do nothing
    if (!textarea) {
      return;
    }

    /**
     * Handles the keydown event for the textarea.
     * Inserts/removes indentation based on Tab/Shift+Tab press.
     * @param {KeyboardEvent} event The keyboard event object.
     */
    const handleKeyDown = (event: KeyboardEvent) => {
      // Only act if the Tab key is pressed
      if (event.key === 'Tab') {
        event.preventDefault(); // Prevent the default tab behavior (moving focus)

        const { selectionStart, selectionEnd, value } = textarea;

        // Determine the start and end of the lines covered by the selection
        const lines = value.split('\n');
        let currentLineStart = 0;
        let startLineIndex = 0;
        let endLineIndex = 0;

        for (let i = 0; i < lines.length; i++) {
          // Use non-null assertion as lines[i] is guaranteed to be a string from .split()
          const lineLength = lines[i]!.length + 1; // +1 for the newline character
          if (selectionStart >= currentLineStart && selectionStart < currentLineStart + lineLength) {
            startLineIndex = i;
          }
          if (selectionEnd >= currentLineStart && selectionEnd < currentLineStart + lineLength) {
            endLineIndex = i;
          }
          currentLineStart += lineLength;
        }

        // Adjust endLineIndex if the selection ends exactly at the beginning of a new line
        if (selectionEnd === currentLineStart - 1 && endLineIndex > startLineIndex) {
            endLineIndex--;
        }

        const selectedLines = lines.slice(startLineIndex, endLineIndex + 1);
        const isMultiLineSelection = startLineIndex !== endLineIndex || (selectionStart !== selectionEnd && selectedLines.length > 1);

        let newSelectionStart: number = selectionStart;
        let newSelectionEnd: number = selectionEnd;
        let newValue: string = value;
        let indentationChange: number = 0; // To track how much the text shifts

        if (event.shiftKey) {
          // --- Shift+Tab (Unindent) ---
          const unindentedLines = selectedLines.map(line => {
            if (line.startsWith(indentString)) {
              indentationChange -= indentString.length;
              return line.substring(indentString.length);
            } else {
              // Also handle cases where the line starts with spaces that match a part of indentString
              let removedSpaces = 0;
              for (let i = 0; i < indentString.length && i < line.length; i++) {
                  if (line[i] === ' ') {
                      removedSpaces++;
                  } else {
                      break;
                  }
              }
              if (removedSpaces > 0) {
                  indentationChange -= removedSpaces;
                  return line.substring(removedSpaces);
              }
            }
            return line;
          });

          // Reconstruct the full text with unindented lines
          const beforeLines = lines.slice(0, startLineIndex).join('\n');
          const afterLines = lines.slice(endLineIndex + 1).join('\n');
          newValue = [beforeLines, unindentedLines.join('\n'), afterLines]
            .filter(Boolean) // Remove empty strings if before/after lines are empty
            .join('\n');

          // Adjust selection start and end based on unindentation
          newSelectionStart = Math.max(0, selectionStart + indentationChange);
          newSelectionEnd = Math.max(0, selectionEnd + indentationChange);

        } else {
          // --- Tab (Indent) ---
          if (isMultiLineSelection || selectionStart !== selectionEnd) {
            // Multi-line indentation
            const indentedLines = selectedLines.map(line => {
              indentationChange += indentString.length;
              return indentString + line;
            });

            // Reconstruct the full text with indented lines
            const beforeLines = lines.slice(0, startLineIndex).join('\n');
            const afterLines = lines.slice(endLineIndex + 1).join('\n');
            newValue = [beforeLines, indentedLines.join('\n'), afterLines]
              .filter(Boolean)
              .join('\n');

            // Adjust selection start and end based on indentation
            newSelectionStart = selectionStart + indentString.length;
            newSelectionEnd = selectionEnd + (indentationChange / selectedLines.length) * selectedLines.length; // Correctly adjust for total indentation
            
          } else {
            // Single line or no selection: insert tab at cursor
            newValue = value.substring(0, selectionStart) + indentString + value.substring(selectionEnd);
            newSelectionStart = newSelectionEnd = selectionStart + indentString.length;
          }
        }

        // Update the textarea's value and selection
        textarea.value = newValue;
        textarea.selectionStart = newSelectionStart;
        textarea.selectionEnd = newSelectionEnd;
      }
    };

    // Add the keydown event listener to the textarea
    textarea.addEventListener('keydown', handleKeyDown);

    // Cleanup function: remove the event listener when the component unmounts
    return () => {
      textarea.removeEventListener('keydown', handleKeyDown);
    };
  }, [indentString]); // Re-run effect if indentString changes

  // Return the ref so the component can attach it to the textarea
  return textareaRef;
}
