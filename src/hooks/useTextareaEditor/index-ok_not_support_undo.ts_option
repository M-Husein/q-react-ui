import { useRef, useEffect } from 'react';

/**
 * A React Hook to enable advanced indentation in a textarea.
 *
 * Features:
 * 1. Tab key inserts a tab character ('\t') at cursor or indents selected lines.
 * 2. Shift+Tab unindents selected lines by removing leading tab characters or a block of spaces
 * equivalent to the visual tab size.
 * 3. Visual tab size is controlled purely by CSS `tab-size` property on the textarea.
 *
 * @param {number} [visualTabSize=4] The visual width of a tab (e.g., 2 or 4 spaces).
 * Used for unindenting blocks of spaces.
 * @returns {React.RefObject<HTMLTextAreaElement | null>} A ref to be attached to the textarea element.
 */
export const useTabToIndent = (visualTabSize: number = 4): React.RefObject<HTMLTextAreaElement | null> => {
  // Create a ref to attach to the textarea element
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // The string to insert for indentation is fixed to a literal tab character
  const TAB_CHAR = '\t';

  useEffect(() => {
    const textarea = textareaRef.current;

    // If the ref is not attached to a textarea yet, or it's unmounted, do nothing
    if (!textarea) {
      return;
    }

    /**
     * Handles the keydown event for the textarea.
     * Inserts/removes indentation based on Tab/Shift+Tab press.
     * @param {KeyboardEvent} event The keyboard event object.
     */
    const handleKeyDown = (event: KeyboardEvent) => {
      // Only act if the Tab key is pressed
      if (event.key === 'Tab') {
        event.preventDefault(); // Prevent the default tab behavior (moving focus)

        const { selectionStart, selectionEnd, value } = textarea;

        // Determine the start and end of the lines covered by the selection
        const lines = value.split('\n');
        let currentLineStart = 0;
        let startLineIndex = 0;
        let endLineIndex = 0;

        for (let i = 0; i < lines.length; i++) {
          // Use non-null assertion as lines[i] is guaranteed to be a string from .split()
          const lineLength = lines[i]!.length + 1; // +1 for the newline character
          if (selectionStart >= currentLineStart && selectionStart < currentLineStart + lineLength) {
            startLineIndex = i;
          }
          if (selectionEnd >= currentLineStart && selectionEnd < currentLineStart + lineLength) {
            endLineIndex = i;
          }
          currentLineStart += lineLength;
        }

        // Adjust endLineIndex if the selection ends exactly at the beginning of a new line
        // This ensures the last line is included in multi-line operations if the cursor is at its start
        if (selectionEnd === currentLineStart - 1 && endLineIndex > startLineIndex) {
            endLineIndex--;
        }

        const selectedLines = lines.slice(startLineIndex, endLineIndex + 1);
        // A selection is considered multi-line if it spans across line breaks
        // OR if it's a non-empty selection that happens to be on a single line
        const isMultiLineSelection = startLineIndex !== endLineIndex || (selectionStart !== selectionEnd && selectedLines.length > 0);


        let newSelectionStart: number = selectionStart;
        let newSelectionEnd: number = selectionEnd;
        let newValue: string = value;
        let indentationChange: number = 0; // To track how much the text shifts

        if (event.shiftKey) {
          // --- Shift+Tab (Unindent) ---
          const unindentedLines = selectedLines.map(line => {
            if (line.startsWith(TAB_CHAR)) {
              indentationChange -= TAB_CHAR.length; // TAB_CHAR.length is 1
              return line.substring(TAB_CHAR.length);
            } else {
              // If no literal tab, try to remove leading spaces equivalent to visualTabSize
              let removedSpaces = 0;
              for (let i = 0; i < visualTabSize && i < line.length; i++) {
                  if (line[i] === ' ') {
                      removedSpaces++;
                  } else {
                      break; // Stop if a non-space character is encountered
                  }
              }
              if (removedSpaces > 0) {
                  indentationChange -= removedSpaces;
                  return line.substring(removedSpaces);
              }
            }
            return line;
          });

          // Reconstruct the full text with unindented lines
          const beforeLines = lines.slice(0, startLineIndex).join('\n');
          const afterLines = lines.slice(endLineIndex + 1).join('\n');
          newValue = [beforeLines, unindentedLines.join('\n'), afterLines]
            .filter(Boolean) // Remove empty strings if before/after lines are empty
            .join('\n');

          // Adjust selection start and end based on unindentation
          newSelectionStart = Math.max(0, selectionStart + indentationChange);
          newSelectionEnd = Math.max(0, selectionEnd + indentationChange);

        } else {
          // --- Tab (Indent) ---
          if (isMultiLineSelection || selectionStart !== selectionEnd) {
            // Multi-line indentation
            const indentedLines = selectedLines.map(line => {
              indentationChange += TAB_CHAR.length; // TAB_CHAR.length is 1
              return TAB_CHAR + line;
            });

            // Reconstruct the full text with indented lines
            const beforeLines = lines.slice(0, startLineIndex).join('\n');
            const afterLines = lines.slice(endLineIndex + 1).join('\n');
            newValue = [beforeLines, indentedLines.join('\n'), afterLines]
              .filter(Boolean)
              .join('\n');

            // Adjust selection start and end based on total indentation added to selected lines
            newSelectionStart = selectionStart + TAB_CHAR.length;
            // The total indentationChange is applied across all lines.
            // newSelectionEnd needs to reflect the total characters added within the selection range.
            newSelectionEnd = selectionEnd + (TAB_CHAR.length * selectedLines.length);
            
          } else {
            // Single line or no selection: insert tab at cursor
            newValue = value.substring(0, selectionStart) + TAB_CHAR + value.substring(selectionEnd);
            newSelectionStart = newSelectionEnd = selectionStart + TAB_CHAR.length;
          }
        }

        // Update the textarea's value and selection
        textarea.value = newValue;
        textarea.selectionStart = newSelectionStart;
        textarea.selectionEnd = newSelectionEnd;
      }
    };

    // Add the keydown event listener to the textarea
    textarea.addEventListener('keydown', handleKeyDown);

    // Cleanup function: remove the event listener when the component unmounts
    return () => {
      textarea.removeEventListener('keydown', handleKeyDown);
    };
  }, [visualTabSize]); // Re-run effect if visualTabSize changes

  // Return the ref so the component can attach it to the textarea
  return textareaRef;
}
